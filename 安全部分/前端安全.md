前端安全是一个大话题, 但是常见攻击方式并且常问的就是XSS和CSRF

## XSS-跨站脚本攻击

简单理解: `攻击者想方设法把可执行的危险代码插入到网页里面`

XSS 分为多种类型, 大致上可以分为两类: **持久性攻击和非持久性攻击**

**持久性攻击** 就是危险代码被写在数据库中, 这种危险性很大, 会导致所有访问该网站的用户受到攻击

比如在可输入评论的网站输入 <script>alert(1)</script>

如果后端没有做好防御, 这段代码就会被写在数据库里, 所有访问该网页的用户都会被攻击

**非持久性攻击** 一般在浏览器地址栏修改url参数来实现

例如:

```html
www.google.com/index.html?name=<script>alert(1)</script>
```

对于这种攻击来说, chrome 会主动帮助用户抵御攻击

但还是要防御, 不能确定每一个用户都使用了 chrome

### 防御(两种方式)

#### 1. 转义字符

首先, 永远不要信任用户的输入, 最普遍的做法是转义输入输出的内容, 对于引号, 尖括号, 斜杠进行转义

```js
function escape(str) {
  str = str.replace(/&/g, '&amp;')
  str = str.replace(/</g, '&lt;')
  str = str.replace(/>/g, '&gt;')
  str = str.replace(/"/g, '&quto;')
  str = str.replace(/'/g, '&#39;')
  str = str.replace(/`/g, '&#96;')
  str = str.replace(/\//g, '&#x2F;')
  return str
} // 转义为html编码

escape('<script>alert(1)</script>')
// 转义为 &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
```

这种做法虽然比较广泛, 但还是有缺点的:

对于富文本来说, 肯定不能通过以上方法转义所有字符, 因为这样也会把格式过滤掉, 对于这种情况, 第二种防御方式就派上了用场

#### 2. 白名单CSP

开发者可以明确告诉浏览器哪些外部资源可以加载执行, 我们只需要配置规则, 如何拦截是浏览器实现

规则: 

1. 设置http响应头: Content-Security-Policy
2. 使用 meta 标签: <meta http-equiv="Content-Security-Policy">

以设置http头为例:

```http
Content-Security-Policy: default-src 'self' // 只允许加载本站资源
Content-Security-Policy: img-src 'https://' // 只允许https加载
Content-Security-Policy: child-src 'none' // 没有限制
```



## CSRF-跨站请求伪造

原理: 攻击者构造出一个后端请求地址, 诱导用户点击或通过某些途径自动发起请求, 如果用户是在登录状态下的话, 后端就会以为是用户在操作, 从而进行相应的逻辑

比如浏览一个博客网站, 点击别人留下的链接, 就可能有CSRF攻击

```html
<img src="http://www.domain.com/xxx?comment='attack'"/>
```

### 防范: 

1. 服务端设置 Get 请求不对数据进行修改
2. 不让第三方网站访问到用户的 Cookie
3. 阻止第三方请求接口
4. 请求时附带验证信息, 常见的 是 token

## 点击攻击

原理: 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。



## 中间人攻击

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。
